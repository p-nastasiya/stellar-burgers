
Поэтому, нет одного коммита, где бы были собраны все изменения, внесённые в код всех файлов проекта, при его отладке.
Комментарии, данные на странице такого коммита, отображаются на странице Пулл реквеста, что удобно и для ревьюера , и для студента.
Поскольку такого коммита нет, приходится все комментарии размещать в общем текущем комментарии.
Ниже такие комментарии приведены (сначала приводится код, к которому дан комментарий, а затем приводится сам комментарий).

Файл app.tsx.

const IngredientDetailsModal: FC = () => {
  const navigate = useNavigate();

  const handleClose = () => {
    navigate(-1);
  };
Можно лучше:
Обработчик handleClose лучше создать в начале компоненты AppContent и передавать его как значение атрибута onClose всем экземплярам компоненты Modal.
Делать обёртку из другой функции-компоненты над вызовом компоненты Modal ни к чему. Обёртывание в данном случае ведёт только к увеличению объёма кода и его дублированию.

useEffect(() => {
    dispatch(fetchIngredients())
      .unwrap()
      .finally(() => dispatch(setAuthChecked(true)));
Надо исправить:
Отправлять экшен setAuthChecked, когда сервер пришлёт ответ на запрос о получении массива ингредиентов, неверно. Массив ингредиентов доступен для просмотра и авторизованным и неавторизованным пользователям. 
Поэтому его получение никак не должно быть связано с проверкой статуса авторизации пользователя.
В других компонентах, в которых должен осуществляться вывод сущностей на экран с использованием данных, содержащихся в массиве ингредиентов, перед выводом нужно определять, содержится ли уже в сторе массив ингредиентов, то есть проверять, не равна ли его длина нулю.
В случае, если массива в сторе ещё нет, нужно включить прелоадер.
В данном случае метод unwrap не нужно присоединять к dispatch(fetchIngredients()).
P.S.
При проверке токенов экшен setAuthChecked отправляется правильно.

Файл burger-ingredients.tsx.

useEffect(() => {
    dispatch(fetchIngredients());
Можно лучше:
Запрос на получение массива ингредиентов лучше посылать только один раз в приложении, в родительской компоненте самого верхнего уровня (App), которая всегда загружается первой при загрузке и перезагрузке приложения.
При этом все другие страницы, поскольку они являются дочерними App, будут иметь доступ к массиву ингредиентов сразу же после своей загрузки, получив их из store.
Поэтому ни в каких других компонентах делать запрос на получение ингредиентов не нужно.
Это уменьшает нагрузку на сервер, и обеспечивает своевременный доступ к массиву ингредиентов (через useSelector) всех других компонент приложения.
В других компонентах, в которых должен осуществляться вывод сущностей на экран с использованием данных, содержащихся в массиве ингредиентов, перед выводом
нужно определять, содержится ли уже в сторе массив ингредиентов, то есть проверять, не равна ли его длина нулю. В случае, если массива в сторе ещё нет, нужно включить прелоадер.

Файл userSlice.ts.

.addCase(fetchUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.user = action.payload;
        //state.isAuthChecked = true;
Можно лучше:
Лучше после получения ответа сервера на запрос в fetchUser изменять значение поля isAuthChecked на true.
Это бы упростило код компоненты ProtectedRoute и уменьшило нагрузку на сервер: в компоненты ProtectedRoute не нужно было бы отправлять экшен fetchUser.
Было бы достаточно проверки, какое значение имеет isAuthChecked.

Файл constructorSlice.ts.

reducers: {
    addBun: (state, action: PayloadAction<TIngredient>) => {
      state.bun = action.payload;
    },
    addIngredient: (state, action: PayloadAction<TIngredient>) => {
      const newIngredient: TConstructorIngredient = {
        ...action.payload,
        id: uuidv4(),
Надо исправить:
Редьюсер должен быть чистой функцией. Поэтому он не должен зависеть от случайных величин. Метод uuidv4 возвращает случайную величину.
Поэтому он должен вызываться в коде экшена addIngredient (который Вы извлекаете из constructorSlice.actions), а не в коде самого редьюсера.
Поэтому в коде поля addIngredient должно использоваться поле prepare, которое и отвечает за код экшена.
Ниже приведён примерный код, как это нужно сделать (структура кода-образца и обозначения переменных в нём может быть не совсем, как у Вас, но Вы сможете адаптировать этот код к своему проекту):

addIngredient: {
      reducer: (state, { payload }: PayloadAction<TConstructorIngredient>) => {
        if (payload.type === 'bun') {
          state.bun = payload;
        } else {
          state.ingredients.push(payload);
        }
      },
      prepare: (ingredient: TIngredient) => ({
        payload: { ...ingredient, id: nanoid() }
      })
}
Что надо исправить.

Не было возможности проверить почти что ни один функционал проекта, так как меню в шапке сайта некликабельно, поскольку в проекте размещён файл AppHeaderUI без ссылок на страницы, связанные с пунктами меню в шапке сайта.
Напоминаю, что по требованию задания, заголовок пункта меню в шапке сайта должен подсвечиваться при его выборе.
Для этого вместо компоненты Link должна использоваться компонента NavLink.
У компоненты NavLink есть встроенное свойство isActive, которое становится равным true при выборе пункта меню.
Как использовать это свойство для подсветки, можно посмотреть в компоненте ProfileMenuUI.

Нужно исправить все критические замечания из категории "Надо исправить", данные в комментариях к коду проекта. Эти комментарии расположены в этом же текущем общем комментарии.

Нужно протестировать работоспособность проекта перед отправкой его на ревью.
Сейчас нет гарантии, что при следующей проверке не обнаружатся дополнительные критические ошибки, не указанные при текущей итерации, поскольку, как уже сказано выше, не было возможности проверить почти ни один функционал проекта в действии.

Что можно улучшить, посмотрите, пожалуйста, комментарии к коду проекта, также расположенные в текущем общем комментарии PR проекта.

Жду откорректированный и отлаженный проект на следующую проверку.

Вы меня извините, что обнуляла проект, после просмотра воркшопа подумала что код можно было улучшить и хотела повторить проект, 
плюс почему то испугалась реиью , подумала что много нужно менять, но потом Максим меня остановил, так как успокоил что  так всё нормально.

